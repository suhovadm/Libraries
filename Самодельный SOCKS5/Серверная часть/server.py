# Исполняемый файл - это server.py, остальные - это подключаемые модули.

# Импортируем зависимости (библиотеки)
import socket # для сетевых соединений
import threading # для многопоточности (обработка нескольких клиентов одноврменно)
import logging # логирование
from server_crypto_utils import CryptoUtils # модуль шифрования
from server_protocol_and_tunneling import ProtocolHandler, TunnelManager # обработчик SOCKS5 протокола
from server_config import ServerConfig # конфигурация сервера подтягивается из последнего файла server_config.py

# ======================================================================================================= #

# _________________ Основной класс сервера. _________________
# host - IP адрес для прослушивания по умолчанию 0.0.0.0/0 - все интерфейсы.
# port - порт для прослушивания по умолчанию 1080 - стандартный для SOCKS.
# max_connections - максимальное кол-во одновременных подключений.
class EncryptedSocksServer:

    # Заводим конструктор.
    # self - ссылка на экземпляр класа (обязательный первый параметр)
    # host=None - параметр для указания IP адреса сервера, по умолчанию None
    # port=None - параметр для указания порта, по умолчанию None
    # max_connections=None - параметр для лимита подключений, по умолчанию тоже None
    def __init__(self, host=None, port=None, max_connections=None):

        # Дальше идут параметры, которые позволяют переопределить значения по умолчанию
        # из конфигурации при создании экземпляра.

        # Присваиваем атрибуту host экземпляр класса (ServerConfig.HOST берётся из server.config.py)

        # Логика операции or:
        # if host is not None:
            # self.host = host
        # else:
        # self.host = ServerConfig.HOST

        # Если host передан (не None) - используется переданное значение.
        # Если host не передан (None) - используется значение из ServerConfig.HOST
        # По умолчанию ServerConfig.HOST = 0.0.0.0 (все сетевые интерфейсы, т.е. сервер будет
        # принимать подключения на всех сетевых интерфейсах машины.

        self.host = host or ServerConfig.HOST
        self.port = port or ServerConfig.PORT # аналогично, но для порта (по умолчанию 1080)

        # Установка максимального количества соединений. По умолчанию 100.
        # Зачем ограничивать подключения?
        # Защита от исчерпания ресурсов сервера + предотвращение DDoS-атак.
        self.max_connections = max_connections or ServerConfig.MAX_CONNECTIONS

        # Запускаем счётчик активных подключений. Тип = целое число (integer).
        # Начальное значение: 0 (сервер только запустился, подключений нет).
        # Зачем это нужно? Отслеживание текущей нагрузки на сервер в реальном времени.
        self.active_connections = 0

        # Создаём объект взаимной блокировки (mutex).
        # threading.Lock() - создаёт примитив синхронизации.
        # Это неблокирующий вызов (создаёт объект, но не блокирует).
        # Объект будет использоваться для синхронизации доступа к разделяемым ресурсам.
        self.connection_lock = threading.Lock()

        # Позволяет корректно завершить работу сервера.
        # Начальное значение = False (сервер работает).
        # shutdown_flag = True (сервер завершит текущие подключения и перестанет принимать новые).
        self.shutdown_flag = False

        # Вызов метода логирования.
        # Устанавливает уровент логирования - INFO.
        self._setup_logging()

        # Шифрование/дешифрование данных. Генерация и проверка HMAC, аутентификация клиентов.
        # Генерация ключей шифрования из пароля, создание токена аутентификации.
        # Настройка алгоритмов AES и HMAC. Создаётся один раз при запуске сервера.
        self.crypto = CryptoUtils()

        # Создаём экземпляр ProtocolHandler c dependency injection.
        # Параметры конструктора:
        # self.crypto - передача объекта криптографии.
        # self.logger - передача логгера.
        # Принцип dependency injection: вместо создания зависимостей внутри, они передаются извне.
        # Назначение ProtocolHandler:
        # Обработка SOCKS5 handshake.
        # Аутентификация клиентов.
        # Парсинг запросов подключения.
        # Установка соединений с целевыми серверами.
        self.protocol = ProtocolHandler(self.crypto, self.logger)

        # Создаём менеджер туннелей с теми же зависимостями.
        # Двусторонняя пересылка данных между клиентом и целевым сервером.
        # Шифрование исходящего трафика.
        # Дешифрование входящего трафика.
        # Управление потоками данных.
        self.tunnel = TunnelManager(self.crypto, self.logger)

# ======================================================================================================= #

    # Заводим функцию _setup_logging(self)
    # В данной секции мы настраиваем КАК логирование будет работать. Основное логирование распределено по всему коду.
    # _ - защитный метод. Это означает "внутренний метод, не предназначенный для внешнего использования".
    # Данный метод используется только внутри класса.
    def _setup_logging(self):

        # Конфиг базового логирования.
        # logging.basicConfig - функция из стандартной библиотеки logging.
        # Настраивает корневой логгер (root logger).
        # Вызывается один раз при старте программы.
        # Устанавливает глобальные параметры логирования.
        logging.basicConfig(

            # Параметр level=logging.INFO
            # logging.DEBUG = 10 - отладочная информация
            # logging.INFO = 20 - информационные сообщения [V]
            # logging.WARNING = 30 - предупреждения
            # logging.ERROR = 40 - ошибки
            # logging.CRITICAL = 50 - критические ошибки

            # В нашем случае, будут записываться сообщения уровня INFO и выше.
            # Не будут записываться DEBUG сообщения.
            # Будут записаны: INFO, WARNING, ERROR и CRITICAL.
            level=logging.INFO,

            # %(asctime)s - временная метка(по умолчанию: 2023-10-12 21:40:32,353)
            # %(levelname)s - уровень логирования (INFO, WARNING, ERROR)
            # %(message)s - текст сообщения

            # Пример вывода:
            # 2023-10-12 21:40:32,353 - INFO - Сервер запущен на 0.0.0.0:1080
            # 2023-10-12 21:40:45,127 - WARNING - Максимум подключений достигнут
            # 2023-10-12 21:41:02,891 - ERROR - Ошибка дешифрования данных

            format='%(asctime)s - %(levelname)s - %(message)s',

            # Вывод лога сразу в консоль и запись в файл:
            handlers=[
                logging.FileHandler('server.log'), # В файл
                logging.StreamHandler()            # и в консоль
            ]
        )

        # Создание логгера для класса.
        # logging.getLogger(__name__) - создаёт или возвращает существующий логгер.
        # __name__ - специальная переменная Python с именем текущего модуля.

        # Если файл запущен напрямую:
        # __name__ = "__main__"

        self.logger = logging.getLogger(__name__)

# ======================================================================================================= #

    # Заводим функцию handle_client с параметрами: self, client_sock, addr.
    # self - ссылка на экземпляр класса.
    # client_sock - socket объект подключенного клиента.
    # addr - кортеж (ip_address, port) клиента.

    # Что происходит при вызове?
    # Когда появляется новое подключение:
    # client_sock, addr = server.accept()
    # Затем в отдельном потоке:
    # self.handle_client(client_sock, addr)
    def handle_client(self, client_sock, addr):

    # Проверка лимита подключений с блокировкой.
    # with self.connection_lock - примитив синхронизации.
    # Гарантирует, что только один поток может выполнять блок кода одновременно.
    # Как работает?
    # Поток 1 входит в with lock -> блокировка захвачена.
    # Поток 2 пытается войти в with lock -> ждёт освобождения.
    # Поток 1 выходит из with lock -> блокировка освобождена.
    # Поток 2 выходит в with lock -> теперь он может работать.
    # Зачем нужен в этом месте?
    # Защита от race condition при изменении self.active_connections.
    # Без блокировки два потока могли бы одновременно:
        # прочитать значение active_connections = 5
        # оба увидеть что лимит достигнут
        with self.connection_lock:

            # Проверка лимита подключений.
            # Если текущее количество подключений >= максимальному разрешенному,
            # говорим: "отклонить новое подключение".
            if self.active_connections >= self.max_connections:

            # Действия при превышении лимита.
            #
                self.logger.warning(f"Max connections reached, rejecting {addr}")
                client_sock.close() # Немедленно закрываем сокет.
                return              # Выходим из функции, поток завершается.

            # Увеличение счётчика.
            # Эта операция происходит только если лимит не превышен.
            # Потокобезопасность гарантирована блокировкой.
            self.active_connections += 1

        # Логирование нового подключения.
        # Позволяет мониторить активность сервера.
        # addr - адрес клиента.
        # active_connections - текущая нагрузка.
        self.logger.info(f"New connection from: {addr} (active: {self.active_connections})")

        # Основная логика обработки.
        try:

        # Внутри происходит следующее:
        # Аутентификация клиента по токену.
        # SOCKS5 handshake - согласование параметров.
        # Получение запроса на подключение к целевому серверу.
        # Установка соединения с целевым сервером.
        # Отправка ответа клиенту.
            remote_sock = self.protocol.handle_handshake(client_sock)

            # При успешности handshake:
            # если remote_sock не None - handshake успешен.
            if remote_sock:

            # Запуск туннелирования.
            # client_sock - сокет клиента.
            # remote_sock - сокет целевого сервера.
            # addr - адрес клиента (для логирования).
            # Что происходит внутри?
            # Создаются два потока для двусторонней пересылки данных.
            # Данные от клиента -> шифруются -> отправляются на целевой сервер.
            # Данные от целевого сервера -> дешифруются -> отправляются клиенту.
                self.tunnel.start_tunnel(client_sock, remote_sock, addr)

        # Обработка ошибок. Тип перехватываемых исключений Exception - все исключения.
        # В чём преимущества?
        # Сервер не падает при ошибке одного клиента.
        # Ошибка логируется для диагностики.
        # Другие клиенты продолжают работать.
        except Exception as e:
            self.logger.error(f"Client {addr} error: {e}")

        # finally - гарантированное выполнение.
        # Данный блок выполняется всегда, независимо от того:
        # успешно ли выполнился блок try,
        # произошло ли исключение,
        # был ли return в середине функции.
        finally:

        # Уменьшение счётчика подключений.
        # Снова используем блокировку.
        # Гарантирует нам, что счётчик всегда корректный.
            with self.connection_lock:
                self.active_connections -= 1

            # Закрываем клиентский сокет.
            try:
                client_sock.close()

            # Игнорирует любые ошибки закрытия сокета.
            except:
                pass

            # Финальное логгирование.
            # Пример вывода:
            # INFO - Connection closed: ('192.168.1.100', 54321) (active: 4)
            # 54321 - это пример порта, он может быть другим...
            self.logger.info(f"Connection closed: {addr} (active: {self.active_connections})")

# ======================================================================================================= #

# Заводим функцию start.
# Что это такое?
# Главный метод запуска сервера, который:
# - создаёт серверный сокет,
# - настраивает его параметры,
# - запускает основной цикл приёма подключений
# - обрабатывает shutdown.
    def start(self):

        # Создаём серверный сокет.
        # socket.AF_INET - семейство адресов.
        # socket.AF_INET - IPv4
        # socket.AF_INET6 - IPv6
        # socket.AF_UNIV - unix domain sockets
        # socket.SOCK_STREAM - тип сокета:
        # socket.SOCK_STREAM - TCP (надёжная передача данных)
        # socket.SOCK_DGRAM - UDP (быстрая, но не надёжная)
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Настройка опции переисполнения адреса.
        # Уровень socket.SQL_SOCKET (уровень сокета)
        # Опция: socket.SO_REUSEADDR (переиспользование адреса)
        # Значение: 1 (включено)

        # Что будет, если не применить REUSEADDR:
        # Сервер запущен на порту 1000 (условно)
        # Нажимаем Ctrl + C, пытаемся сразу перезапустить
        # Получаем ошибку: "Address already in use"
        # Причина: ОС содержит порт занятым 1-2 минуты (TIME_WAIT state)
        # TIME_WAIT - это защита от старых данных, которые могли задержаться в сети.
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # Привязываем сокет к адресу и к порту.
        # self.host - 0.0.0.0 (все интерфейсы)
        # self.port - 1080 (стандартный для SOCKS порт)
        server.bind((self.host, self.port))

        # Переводим сокет в режим прослушивания.
        # server.listen(5) - очередь из 5 ожидающих подключений.
        # Клиент 6 будет отклонён (connection refused).
        # Зачем нужна очередь?
        # Сглаживание пиковой нагрузки, когда сервер временно не успевает
        # обрабатывать новые подключения.
        server.listen(5)

        # Логирование запуска сервера.
        # Пример вывода:
        # INFO - Encrypted SOCKS5 server started on 0.0.0.0:1080
        # INFO - Configuration: {'host': '0.0.0.0', 'port': 1080, 'max_connections': 100, ...}
        # Зачем это нужно?
        # Подтверждение успешного запуска.
        # Детали конфига для отладки.
        # Точка отсчёта в логах на которую можно опереться.
        self.logger.info(f"Encrypted SOCKS5 server started on {self.host}:{self.port}")
        self.logger.info(f"Configuration: {ServerConfig.to_dict()}")

        # Главный цикл сервера.
        try:
            while(True):
                # Блокирующий вызов. Что происходит?
                # Программа "засыпает" на этой строке.
                # Просыпается когда появляется новое подключение.
                # Возвращает кортеж (client_socket, client_address)
                client_sock, addr = server.accept() # блокирующий вызов.

                # Создаём поток для клиента.
                # Что такое демон-поток?
                # Завершается автоматически когда завершается главный поток.
                # Не блокирует завершение программы.
                # Что будет, если не указать daemon=True?
                # Рабочие потоки продолжат работать и программа не завершится полностью.
                thread = threading.Thread(
                    target=self.handle_client, # Функция для выполнения,
                    args=(client_sock, addr),   # аргументы функции,
                    daemon=True                 # демон-поток.
                )

                # Запуск потока.
                # Запускает handle_client в отдельном потоке.
                # Архитектура "один клиент - один поток".
                thread.start()

        # Обработка завершения работы.
        # Когда пользователь нажал Ctrl + C, происходит shutdown с информативным логом.
        except KeyboardInterrupt:
            self.logger.info("Server stopped by user")

        # Обработка других исключений.
        # Перехватывает любые непредвиденные ошибки без логирования.
        except Exception as e:
            self.logger.error(f"Server error: {e}")

        # Гарантированное выполнение.
        # Выполняется после нормального завершения, после KeyboardInterrupt, после любой ошибки.
        # Важность server.close() - высвобождение сетевых ресурсов и порта.
        finally:
            server.close()
            self.logger.info("Server shutdown complete")

# ======================================================================================================= #

# Запускаем сервер.
if __name__ == "__main__":
    server = EncryptedSocksServer()
    server.start()