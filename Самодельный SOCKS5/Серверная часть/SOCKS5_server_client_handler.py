# 5. Модуль обработки клиентских подключений

import threading # обеспечивает многопоточность и синхронизацию.
from SOCKS5_server_logging import LoggingSetup # предоставляет систему логирования для отслеживания работы сервера.

# Заводим класс.
class ClientHandler:
    # Заводим конструктор с параметрами.
    def __init__(self, crypto, protocol, tunnel, max_connections):
        self.crypto = crypto # объект для шифрования/дешифрования данных.
        self.protocol = protocol # обработчик SOCKS5 протокола (рукопожатие, аутентификация)
        self.tunnel = tunnel # менеджер туннелирования (пересылка данных между клиентом и целевым сервером)
        self.logger = LoggingSetup.setup_logging() # инициализация логирования.
        self.active_connections = 0 # счётчик активных клиентских подключений.
        self.connection_lock = threading.Lock() # объект блокировки для синхронизации потоков.
        # Важно! Создание объекта Lock (threading.Lock()) не блокирует выполнение - это просто
        # создание объекта. Блокировка происходит только при вызове lock.acquire() или при входе
        # в контекстный менеджер 'with lock'.
        self.max_connections = max_connections # максимальное количество одновременных подключений.

    # Заводим функцию handle_client с параметрами: self, client_sock, addr.
    # self - ссылка на экземпляр класса.
    # client_sock - socket объект подключенного клиента.
    # addr - кортеж (ip_address, port) клиента.

    # Что происходит при вызове?
    # Когда появляется новое подключение:
    # client_sock, addr = server.accept()
    # Затем в отдельном потоке:
    # self.handle_client(client_sock, addr)
    def handle_client(self, client_sock, addr):

    # Проверка лимита подключений с блокировкой.
    # with self.connection_lock - примитив синхронизации.
    # Гарантирует, что только один поток может выполнять блок кода одновременно.
    # Как работает?
    # Поток 1 входит в with lock -> блокировка захвачена.
    # Поток 2 пытается войти в with lock -> ждёт освобождения.
    # Поток 1 выходит из with lock -> блокировка освобождена.
    # Поток 2 выходит в with lock -> теперь он может работать.
    # Зачем нужен в этом месте?
    # Защита от race condition при изменении self.active_connections.
    # Без блокировки возможна race condition:
        # 1. Поток А читает active_connections = 4 (лимит 5)
        # 2. Поток B читает active_connections = 4 (лимит 5)
        # 3. Оба потока увеличивают счётчик до 6 - превышение лимита.
        with self.connection_lock:

            # Проверка лимита подключений.
            # Если текущее количество подключений >= максимальному разрешенному,
            # говорим: "отклонить новое подключение".
            if self.active_connections >= self.max_connections:

            # Действия при превышении лимита.
                self.logger.warning(f"Max connections reached, rejecting {addr}")
                client_sock.close() # Немедленно закрываем сокет.
                return              # Выходим из функции, поток завершается.

            # Увеличение счётчика.
            # Эта операция происходит только если лимит не превышен.
            # Потокобезопасность гарантирована блокировкой.
            self.active_connections += 1

        # Логирование нового подключения.
        # Позволяет мониторить активность сервера.
        # addr - адрес клиента.
        # active_connections - текущая нагрузка.
        self.logger.info(f"New connection from: {addr} (active: {self.active_connections})")

        # Основная логика обработки.
        try:

        # Внутри происходит следующее:
        # Аутентификация клиента по токену.
        # SOCKS5 handshake - согласование параметров.
        # Получение запроса на подключение к целевому серверу.
        # Установка соединения с целевым сервером.
        # Отправка ответа клиенту.
            remote_sock = self.protocol.handle_handshake(client_sock)

            # При успешности handshake:
            # если remote_sock не None - handshake успешен.
            if remote_sock:

            # Запуск туннелирования.
            # client_sock - сокет клиента.
            # remote_sock - сокет целевого сервера.
            # addr - адрес клиента (для логирования).
            # Что происходит внутри?
            # Создаются два потока для двусторонней пересылки данных.
            # Данные от клиента -> шифруются -> отправляются на целевой сервер.
            # Данные от целевого сервера -> дешифруются -> отправляются клиенту.
                self.tunnel.start_tunnel(client_sock, remote_sock, addr)

        # Обработка ошибок. Тип перехватываемых исключений Exception - все исключения.
        # Перехватываем все исключения (exception) чтобы:
        # - сервер продолжал работать при ошибках отдельных клиентов,
        # - логировать ошибки для диагностики,
        # - гарантированно освобождать ресурсы в блоке finally.
        except Exception as e:
            self.logger.error(f"Client {addr} error: {e}")

        # finally - гарантированное выполнение.
        # Данный блок выполняется всегда, независимо от того:
        # успешно ли выполнился блок try,
        # произошло ли исключение,
        # был ли return в середине функции.
        finally:

        # Уменьшение счётчика подключений.
        # Снова используем блокировку.
        # Гарантирует нам, что счётчик всегда корректный.
            with self.connection_lock:
                self.active_connections -= 1

            # Закрываем клиентский сокет.
            try:
                client_sock.close()

            # Игнорирует любые ошибки закрытия сокета.
            except:
                pass

            # Финальное логирование.
            # Пример вывода:
            # INFO - Connection closed: ('192.168.1.100', 54321) (active: 4)
            # active: 4 - это количество текущих активных подключений к SOCKS5 серверу в момент
            # закрытия этого конкретного соединения.
            # 54321 - это пример порта, он может быть другим...
            # addr содержит (IP адрес и порт клиента) - это порт на стороне клиента,
            # который используется для этого соединения.
            self.logger.info(f"Connection closed: {addr} (active: {self.active_connections})")