# 6. Главный координационный центр всего SOCKS5 прокси-сервера,
# который объединяет все компоненты системы и управляет их работой.

import socket # отвечает за работу с сетью.
import threading # многопоточность для обработки клиентов.
from SOCKS5_server_crypto_utils import CryptoUtils # модуль шифрования и аутентификации.
from SOCKS5_server_protocol_and_tunneling import ProtocolHandler, TunnelManager # протокол туннелирования.
from SOCKS5_server_config import ServerConfig # основной конфиг прокси-сервера.
from SOCKS5_server_logging import LoggingSetup # настройки логирования.
from SOCKS5_server_client_handler import ClientHandler # обработчик клиентских подключений.

# ======================================================================================================= #

# _________________ Архитектура сервера. _________________
# 1. Main thread - принятие подключений (server.accept())
# 2. Worker threads - обработка клиентов (ClientHandler)
# 3. Tunnel threads - передача данных внутри каждого клиента

# _________________ Основной класс сервера. _________________
# host - IP адрес для прослушивания по умолчанию 0.0.0.0/0 - все интерфейсы.
# port - порт для прослушивания по умолчанию 1080 - стандартный для SOCKS.
# max_connections - максимальное кол-во одновременных подключений.
class EncryptedSocksServer:

    # Заводим конструктор.
    # self - ссылка на экземпляр класа (обязательный первый параметр)
    # host=None - параметр для указания IP адреса сервера, по умолчанию None
    # port=None - параметр для указания порта, по умолчанию None
    # max_connections=None - параметр для лимита подключений, по умолчанию тоже None
    def __init__(self, host=None, port=None, max_connections=None):

        # Дальше идут параметры, которые позволяют переопределить значения по умолчанию
        # из конфигурации при создании экземпляра.

        # Присваиваем атрибуту host экземпляр класса (ServerConfig.HOST берётся из server.config.py)

        # Логика операции or:
        # if host is not None:
            # self.host = host
        # else:
        # self.host = ServerConfig.HOST

        # Если host передан (не None) - используется переданное значение.
        # Если host не передан (None) - используется значение из ServerConfig.HOST
        # По умолчанию ServerConfig.HOST = 0.0.0.0 (все сетевые интерфейсы, т.е. сервер будет
        # принимать подключения на всех сетевых интерфейсах машины.

        self.host = host or ServerConfig.HOST
        self.port = port or ServerConfig.PORT # аналогично, но для порта (по умолчанию 1080)

        # Установка максимального количества соединений. По умолчанию 100.
        # Зачем ограничивать подключения?
        # Защита от исчерпания ресурсов сервера + предотвращение DDoS-атак.
        self.max_connections = max_connections or ServerConfig.MAX_CONNECTIONS

        # Вызов метода логирования.
        # Устанавливает уровень логирования - INFO.
        self.logger = LoggingSetup.setup_logging()

        # Шифрование/дешифрование данных. Генерация и проверка HMAC, аутентификация клиентов.
        # Генерация ключей шифрования из пароля, создание токена аутентификации.
        # Настройка алгоритмов AES и HMAC. Создаётся один раз при запуске сервера.
        self.crypto = CryptoUtils()

        # Создаём экземпляр ProtocolHandler c dependency injection.
        # Параметры конструктора:
        # self.crypto - передача объекта криптографии.
        # self.logger - передача логгера.
        # Принцип dependency injection: вместо создания зависимостей внутри, они передаются извне.
        # Назначение ProtocolHandler:
            # Обработка SOCKS5 handshake.
            # Аутентификация клиентов.
            # Парсинг запросов подключения.
            # Установка соединений с целевыми серверами.
        self.protocol = ProtocolHandler(self.crypto, self.logger)

        # Создаём менеджер туннелей с теми же зависимостями.
        # Двусторонняя пересылка данных между клиентом и целевым сервером.
        # Шифрование исходящего трафика.
        # Дешифрование входящего трафика.
        # Управление потоками данных.
        self.tunnel = TunnelManager(self.crypto, self.logger)

        # Создаём обработчик клиентов
        self.client_handler = ClientHandler(self.crypto, self.protocol, self.tunnel, self.max_connections)

        # Позволяет корректно завершить работу сервера.
        # Начальное значение = False (сервер работает).
        # shutdown_flag = True (сервер завершит текущие подключения и перестанет принимать новые).
        self.shutdown_flag = False

# ======================================================================================================= #

# Заводим функцию start. Главный метод запуска SOCKS5 сервера.
# Что это такое?
# Главный метод запуска сервера, который:
# - создаёт серверный сокет,
# - настраивает его параметры,
# - запускает основной цикл приёма подключений
# - обрабатывает shutdown.

# Архитектура:
    # Основной поток: принятие подключений (accept())
    # Рабочие потоки: обработка клиентов (по одному на клиента)
    # Демон-потоки: автоматическое завершение при остановке сервера
    def start(self):

        # Создаём серверный сокет IPv4.
        # socket.AF_INET - семейство адресов.
        # socket.AF_INET - IPv4
        # socket.AF_INET6 - IPv6
        # socket.AF_UNIV - unix domain sockets
        # socket.SOCK_STREAM - тип сокета:
        # socket.SOCK_STREAM - TCP (надёжная передача данных)
        # socket.SOCK_DGRAM - UDP (быстрая, но не надёжная)
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Настройка опции переисполнения адреса для быстрого перезапуска.
        # Уровень socket.SQL_SOCKET (уровень сокета)
        # Опция: socket.SO_REUSEADDR (переиспользование адреса)
        # *** SO_REUSEADDR позволяет перезапустить сервер сразу после паузы. ***
        # Значение: 1 (включено)

        # Что будет, если не применить REUSEADDR:
        # Сервер запущен на порту 1000 (условно)
        # Нажимаем Ctrl + C, пытаемся сразу перезапустить
        # Получаем ошибку: "Address already in use"
        # Причина: ОС держит порт занятым 1-2 минуты (TIME_WAIT state)
        # TIME_WAIT - это защита от старых данных, которые могли задержаться в сети.
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # Привязываем сокет к адресу и к порту.
        # self.host - 0.0.0.0 (все интерфейсы)
        # self.port - 1080 (стандартный для SOCKS порт)
        server.bind((self.host, self.port))

        # Переводим сокет в режим прослушивания с очередью до 5 подключений.
        # server.listen(5) - очередь из 5 ожидающих подключений.
        # server.listen(5) - очередь до 5 ожидающих подключений.
        # Клиент 6 получит Connection refused, если все 5 слотов заняты.
        # На практике это редко происходит, т.к. accept() быстро обрабатывает подключения.
            # Зачем нужна очередь?
            # Сглаживание пиковой нагрузки, когда сервер временно не успевает
            # обрабатывать новые подключения.
        server.listen(5)

        # Логирование запуска сервера.
        # Пример вывода:
        # INFO - Encrypted SOCKS5 server started on 0.0.0.0:1080
        # INFO - Configuration: {'host': '0.0.0.0', 'port': 1080, 'max_connections': 100, ...}
        # Зачем это нужно?
        # Подтверждение успешного запуска.
        # Детали конфига для отладки.
        # Точка отсчёта в логах на которую можно опереться.
        self.logger.info(f"Encrypted SOCKS5 server started on {self.host}:{self.port}")
        self.logger.info(f"Configuration: {ServerConfig.to_dict()}")

        # Главный цикл сервера.
        try:
            while(True):
                # Блокирующий вызов. Что происходит?
                # Программа "засыпает" на этой строке.
                # Просыпается когда появляется новое подключение.
                # Возвращает кортеж (client_socket, client_address)
                client_sock, addr = server.accept() # блокирующий вызов.

                # Создаём поток для клиента.
                # Что такое демон-поток?
                # Завершается автоматически когда завершается главный поток.
                # Не блокирует завершение программы.
                # Что будет, если не указать daemon=True?
                # Без daemon=True главный поток будет ждать завершения всех рабочих потоков.
                # daemon=True гарантирует, что при завершении главного потока все рабочие потоки
                # будут принудительно завершены.
                thread = threading.Thread(
                    target=self.client_handler.handle_client, # Функция для выполнения,
                    args=(client_sock, addr),   # аргументы функции,
                    daemon=True                 # демон-поток.
                )

                # Запуск потока.
                # Запускает handle_client в отдельном потоке.
                # Архитектура "один клиент - один поток".
                thread.start()

        # Обработка завершения работы.
        # Когда пользователь нажал Ctrl + C, происходит shutdown с информативным логом.
        except KeyboardInterrupt:
            self.logger.info("Server stopped by user")

        # Обработка других исключений.
        # Логируем ошибку, но сервер продолжает работать -
        # это защита от падения при единичных сетевых сбоях.
        except Exception as e:
            self.logger.error(f"Server error: {e}")

        # Гарантированное выполнение.
        # Выполняется после нормального завершения, после KeyboardInterrupt, после любой ошибки.
        # Важность server.close() - высвобождение сетевых ресурсов и порта.
        finally:
            server.close()
            self.logger.info("Server shutdown complete")