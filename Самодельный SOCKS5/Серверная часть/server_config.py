# Импортируем библиотеки.

import os # для работы с операционной системой. Позволяет получать переменные окружения через os.getenv()
from typing import Dict, Any # импортирует типы аннотаций: dict для словарей, any - для значений любого типа

# Заводим класс ServerConfig.
class ServerConfig:
    """Конфигурация сервера"""

# ----- ЗДЕСЬ НАЧИНАЕТ РАБОТУ ДЕКОРАТОР. -----

    # Настройки сети.
    # Получаем хост сервера из переменной окружения SOCKS_SERVER_HOST
    # Если переменная не установлена, использует значение по умолчанию 0.0.0.0 (все сетевые интерфейсы)
    HOST = os.getenv('SOCKS_SERVER_HOST', '0.0.0.0')
    # Получаем порт из переменной окружения SOCKS_SERVER_PORT, значение по умолчанию 1080 (стандартный для SOCKS)
    # int() преобразует строку в число.
    PORT = int(os.getenv('SOCKS_SERVER_PORT', '1080'))
    # Максимальное количество одновременных подключений.
    # По умолчанию: 100 соединений.
    MAX_CONNECTIONS = int(os.getenv('SOCKS_MAX_CONNECTIONS', '100'))

    # Настройки безопасности.
    # Пароль для генерации ключей шифрования.
    PASSWORD = os.getenv('SOCKS_PASSWORD', '123456789')
    # Секретный ключ для создания токенов аутентификации.
    # Используется для верификации клиентов.
    AUTH_TOKEN_SECRET = os.getenv('SOCKS_AUTH_SECRET', 'secret_auth_token')

    # Настройки производительности.
    # Таймаут для фразы handshake (установления соединения).
    # 10 секунд - время ожидания завершения аутентификации и согласования параметров.
    HANDSHAKE_TIMEOUT = 10.0
    # Таймаут для работы туннеля передачи данных.
    # 30 секунд - время ожидания данных в активном соединении.
    TUNNEL_TIMEOUT = 30.0
    # Максимальный размер данных за одну операцию передачи.
    # Защита от переполнения памяти и DoS-атак.
    MAX_DATA_SIZE = 10 * 1024 * 1024  # 10 мегабайт.

# ----- ЗДЕСЬ ЗАКАНЧИВАЕТ РАБОТУ ДЕКОРАТОР. -----

    # Настройки шифрования
    # Параметр для генерации ключа шифрования.
    # b'salt_enc - байтовая строка (8 байт).
    # Используется в PBKDF2 для усиления пароля.
    ENCRYPTION_SALT = b'salt_enc'
    # Параметр для генерации ключа аутентификации.
    # Отличается от параметра шифрования для разделения ключей.
    AUTHENTICATION_SALT = b'salt_auth'
    # Количество итераций алгоритма PBKDF2
    # 100000 итераций делают brute-force атаки крайне не выгодными.
    PBKDF2_ITERATIONS = 100000

    # Запрещенные подсети, указаны в формате CIDR.
    FORBIDDEN_NETWORKS = [
        '127.0.0.0/8', # loopback-и и localhost-ы, запрещает подключение к самому себе
        '10.0.0.0/8', # частная сеть класса А, диапазон 10.0.0.0 - 10.255.255.255
        '172.16.0.0/12', # частная сеть класса B, диапазон 172.16.0.0 - 172.31.255.255
        '192.168.0.0/16', # частная сеть класса C, диапазон 192.168.0.0 - 192.168.255.255
    ]

# Декоратор @classmethod автоматически передаёт класс ServerConfig в качестве первого аргумента.
# А дальше уже идёт то, что записано в return под функцией def to dict(cls)... внутри декоратора.
# Проще говоря, декоратор - это волшебный указатель, который работает со всем классом сразу.
# А если быть ещё точнее, то с теми параметрами, что в нём есть.
    @classmethod

    # Возвращает конфигурацию в виде словаря.
    def to_dict(cls) -> Dict[str, Any]:

        return {
            'host': cls.HOST, # ключ host:host
            'port': cls.PORT, # ключ port:port
            'max_connections': cls.MAX_CONNECTIONS, # ключ max_connections с максимальным кол-вом соединений
            'handshake_timeout': cls.HANDSHAKE_TIMEOUT, # ключ handshake с таймаутом handshake
            'tunnel_timeout': cls.TUNNEL_TIMEOUT, # ключ tunnel_timeout с таймаутом туннеля
            'max_data_size': cls.MAX_DATA_SIZE, # ключ max_data_size с максимальным размером данных

        }
